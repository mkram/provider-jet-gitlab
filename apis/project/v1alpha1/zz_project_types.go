/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ProjectObservation struct {
	HTTPURLToRepo *string `json:"httpUrlToRepo,omitempty" tf:"http_url_to_repo,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	PathWithNamespace *string `json:"pathWithNamespace,omitempty" tf:"path_with_namespace,omitempty"`

	SSHURLToRepo *string `json:"sshUrlToRepo,omitempty" tf:"ssh_url_to_repo,omitempty"`

	WebURL *string `json:"webUrl,omitempty" tf:"web_url,omitempty"`
}

type ProjectParameters struct {

	// Set to true if you want to treat skipped pipelines as if they finished with success.
	// +kubebuilder:validation:Optional
	AllowMergeOnSkippedPipeline *bool `json:"allowMergeOnSkippedPipeline,omitempty" tf:"allow_merge_on_skipped_pipeline,omitempty"`

	// Number of merge request approvals required for merging. Default is 0.
	// +kubebuilder:validation:Optional
	ApprovalsBeforeMerge *float64 `json:"approvalsBeforeMerge,omitempty" tf:"approvals_before_merge,omitempty"`

	// Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.
	// +kubebuilder:validation:Optional
	ArchiveOnDestroy *bool `json:"archiveOnDestroy,omitempty" tf:"archive_on_destroy,omitempty"`

	// Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.
	// +kubebuilder:validation:Optional
	Archived *bool `json:"archived,omitempty" tf:"archived,omitempty"`

	// Test coverage parsing for the project.
	// +kubebuilder:validation:Optional
	BuildCoverageRegex *string `json:"buildCoverageRegex,omitempty" tf:"build_coverage_regex,omitempty"`

	// Custom Path to CI config file.
	// +kubebuilder:validation:Optional
	CiConfigPath *string `json:"ciConfigPath,omitempty" tf:"ci_config_path,omitempty"`

	// When a new deployment job starts, skip older deployment jobs that are still pending.
	// +kubebuilder:validation:Optional
	CiForwardDeploymentEnabled *bool `json:"ciForwardDeploymentEnabled,omitempty" tf:"ci_forward_deployment_enabled,omitempty"`

	// Enable container registry for the project.
	// +kubebuilder:validation:Optional
	ContainerRegistryEnabled *bool `json:"containerRegistryEnabled,omitempty" tf:"container_registry_enabled,omitempty"`

	// The default branch for the project.
	// +kubebuilder:validation:Optional
	DefaultBranch *string `json:"defaultBranch,omitempty" tf:"default_branch,omitempty"`

	// A description of the project.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use_custom_template to be true (enterprise edition).
	// +kubebuilder:validation:Optional
	GroupWithProjectTemplatesID *float64 `json:"groupWithProjectTemplatesId,omitempty" tf:"group_with_project_templates_id,omitempty"`

	// Git URL to a repository to be imported.
	// +kubebuilder:validation:Optional
	ImportURL *string `json:"importUrl,omitempty" tf:"import_url,omitempty"`

	// Create main branch with first commit containing a README.md file.
	// +kubebuilder:validation:Optional
	InitializeWithReadme *bool `json:"initializeWithReadme,omitempty" tf:"initialize_with_readme,omitempty"`

	// Enable issue tracking for the project.
	// +kubebuilder:validation:Optional
	IssuesEnabled *bool `json:"issuesEnabled,omitempty" tf:"issues_enabled,omitempty"`

	// Sets the template for new issues in the project.
	// +kubebuilder:validation:Optional
	IssuesTemplate *string `json:"issuesTemplate,omitempty" tf:"issues_template,omitempty"`

	// Enable LFS for the project.
	// +kubebuilder:validation:Optional
	LfsEnabled *bool `json:"lfsEnabled,omitempty" tf:"lfs_enabled,omitempty"`

	// Set to `ff` to create fast-forward merges
	// +kubebuilder:validation:Optional
	MergeMethod *string `json:"mergeMethod,omitempty" tf:"merge_method,omitempty"`

	// Enable or disable merge pipelines.
	// +kubebuilder:validation:Optional
	MergePipelinesEnabled *bool `json:"mergePipelinesEnabled,omitempty" tf:"merge_pipelines_enabled,omitempty"`

	// Enable merge requests for the project.
	// +kubebuilder:validation:Optional
	MergeRequestsEnabled *bool `json:"mergeRequestsEnabled,omitempty" tf:"merge_requests_enabled,omitempty"`

	// Sets the template for new merge requests in the project.
	// +kubebuilder:validation:Optional
	MergeRequestsTemplate *string `json:"mergeRequestsTemplate,omitempty" tf:"merge_requests_template,omitempty"`

	// Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.
	// +kubebuilder:validation:Optional
	MergeTrainsEnabled *bool `json:"mergeTrainsEnabled,omitempty" tf:"merge_trains_enabled,omitempty"`

	// Enable project pull mirror.
	// +kubebuilder:validation:Optional
	Mirror *bool `json:"mirror,omitempty" tf:"mirror,omitempty"`

	// Enable overwrite diverged branches for a mirrored project.
	// +kubebuilder:validation:Optional
	MirrorOverwritesDivergedBranches *bool `json:"mirrorOverwritesDivergedBranches,omitempty" tf:"mirror_overwrites_diverged_branches,omitempty"`

	// Enable trigger builds on pushes for a mirrored project.
	// +kubebuilder:validation:Optional
	MirrorTriggerBuilds *bool `json:"mirrorTriggerBuilds,omitempty" tf:"mirror_trigger_builds,omitempty"`

	// The namespace (group or user) of the project. Defaults to your user.
	// +kubebuilder:validation:Optional
	NamespaceID *float64 `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// Set to true if you want allow merges only if all discussions are resolved.
	// +kubebuilder:validation:Optional
	OnlyAllowMergeIfAllDiscussionsAreResolved *bool `json:"onlyAllowMergeIfAllDiscussionsAreResolved,omitempty" tf:"only_allow_merge_if_all_discussions_are_resolved,omitempty"`

	// Set to true if you want allow merges only if a pipeline succeeds.
	// +kubebuilder:validation:Optional
	OnlyAllowMergeIfPipelineSucceeds *bool `json:"onlyAllowMergeIfPipelineSucceeds,omitempty" tf:"only_allow_merge_if_pipeline_succeeds,omitempty"`

	// Enable only mirror protected branches for a mirrored project.
	// +kubebuilder:validation:Optional
	OnlyMirrorProtectedBranches *bool `json:"onlyMirrorProtectedBranches,omitempty" tf:"only_mirror_protected_branches,omitempty"`

	// Enable packages repository for the project.
	// +kubebuilder:validation:Optional
	PackagesEnabled *bool `json:"packagesEnabled,omitempty" tf:"packages_enabled,omitempty"`

	// Enable pages access control
	// +kubebuilder:validation:Optional
	PagesAccessLevel *string `json:"pagesAccessLevel,omitempty" tf:"pages_access_level,omitempty"`

	// The path of the repository.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Enable pipelines for the project.
	// +kubebuilder:validation:Optional
	PipelinesEnabled *bool `json:"pipelinesEnabled,omitempty" tf:"pipelines_enabled,omitempty"`

	// Show link to create/view merge request when pushing from the command line
	// +kubebuilder:validation:Optional
	PrintingMergeRequestLinkEnabled *bool `json:"printingMergeRequestLinkEnabled,omitempty" tf:"printing_merge_request_link_enabled,omitempty"`

	// Push rules for the project.
	// +kubebuilder:validation:Optional
	PushRules []PushRulesParameters `json:"pushRules,omitempty" tf:"push_rules,omitempty"`

	// Enable `Delete source branch` option by default for all new merge requests.
	// +kubebuilder:validation:Optional
	RemoveSourceBranchAfterMerge *bool `json:"removeSourceBranchAfterMerge,omitempty" tf:"remove_source_branch_after_merge,omitempty"`

	// Allow users to request member access.
	// +kubebuilder:validation:Optional
	RequestAccessEnabled *bool `json:"requestAccessEnabled,omitempty" tf:"request_access_enabled,omitempty"`

	// Enable shared runners for this project.
	// +kubebuilder:validation:Optional
	SharedRunnersEnabled *bool `json:"sharedRunnersEnabled,omitempty" tf:"shared_runners_enabled,omitempty"`

	// Enable snippets for the project.
	// +kubebuilder:validation:Optional
	SnippetsEnabled *bool `json:"snippetsEnabled,omitempty" tf:"snippets_enabled,omitempty"`

	// Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab >= 14.1]
	// +kubebuilder:validation:Optional
	SquashOption *string `json:"squashOption,omitempty" tf:"squash_option,omitempty"`

	// Tags (topics) of the project.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// When used without use_custom_template, name of a built-in project template. When used with use_custom_template, name of a custom project template. This option is mutually exclusive with `template_project_id`.
	// +kubebuilder:validation:Optional
	TemplateName *string `json:"templateName,omitempty" tf:"template_name,omitempty"`

	// When used with use_custom_template, project ID of a custom project template. This is preferable to using template_name since template_name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`.
	// +kubebuilder:validation:Optional
	TemplateProjectID *float64 `json:"templateProjectId,omitempty" tf:"template_project_id,omitempty"`

	// Use either custom instance or group (with group_with_project_templates_id) project template (enterprise edition).
	// +kubebuilder:validation:Optional
	UseCustomTemplate *bool `json:"useCustomTemplate,omitempty" tf:"use_custom_template,omitempty"`

	// Set to `public` to create a public project.
	// +kubebuilder:validation:Optional
	VisibilityLevel *string `json:"visibilityLevel,omitempty" tf:"visibility_level,omitempty"`

	// Enable wiki for the project.
	// +kubebuilder:validation:Optional
	WikiEnabled *bool `json:"wikiEnabled,omitempty" tf:"wiki_enabled,omitempty"`
}

type PushRulesObservation struct {
}

type PushRulesParameters struct {

	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	// +kubebuilder:validation:Optional
	AuthorEmailRegex *string `json:"authorEmailRegex,omitempty" tf:"author_email_regex,omitempty"`

	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	// +kubebuilder:validation:Optional
	BranchNameRegex *string `json:"branchNameRegex,omitempty" tf:"branch_name_regex,omitempty"`

	// Users can only push commits to this repository that were committed with one of their own verified emails.
	// +kubebuilder:validation:Optional
	CommitCommitterCheck *bool `json:"commitCommitterCheck,omitempty" tf:"commit_committer_check,omitempty"`

	// No commit message is allowed to match this regex, for example `ssh\:\/\/`.
	// +kubebuilder:validation:Optional
	CommitMessageNegativeRegex *string `json:"commitMessageNegativeRegex,omitempty" tf:"commit_message_negative_regex,omitempty"`

	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	// +kubebuilder:validation:Optional
	CommitMessageRegex *string `json:"commitMessageRegex,omitempty" tf:"commit_message_regex,omitempty"`

	// Deny deleting a tag.
	// +kubebuilder:validation:Optional
	DenyDeleteTag *bool `json:"denyDeleteTag,omitempty" tf:"deny_delete_tag,omitempty"`

	// All commited filenames must not match this regex, e.g. `(jar|exe)$`.
	// +kubebuilder:validation:Optional
	FileNameRegex *string `json:"fileNameRegex,omitempty" tf:"file_name_regex,omitempty"`

	// Maximum file size (MB).
	// +kubebuilder:validation:Optional
	MaxFileSize *float64 `json:"maxFileSize,omitempty" tf:"max_file_size,omitempty"`

	// Restrict commits by author (email) to existing GitLab users.
	// +kubebuilder:validation:Optional
	MemberCheck *bool `json:"memberCheck,omitempty" tf:"member_check,omitempty"`

	// GitLab will reject any files that are likely to contain secrets.
	// +kubebuilder:validation:Optional
	PreventSecrets *bool `json:"preventSecrets,omitempty" tf:"prevent_secrets,omitempty"`

	// Reject commit when it’s not signed through GPG.
	// +kubebuilder:validation:Optional
	RejectUnsignedCommits *bool `json:"rejectUnsignedCommits,omitempty" tf:"reject_unsigned_commits,omitempty"`
}

// ProjectSpec defines the desired state of Project
type ProjectSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ProjectParameters `json:"forProvider"`
}

// ProjectStatus defines the observed state of Project.
type ProjectStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ProjectObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Project is the Schema for the Projects API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gitlabjet}
type Project struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProjectSpec   `json:"spec"`
	Status            ProjectStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ProjectList contains a list of Projects
type ProjectList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Project `json:"items"`
}

// Repository type metadata.
var (
	Project_Kind             = "Project"
	Project_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Project_Kind}.String()
	Project_KindAPIVersion   = Project_Kind + "." + CRDGroupVersion.String()
	Project_GroupVersionKind = CRDGroupVersion.WithKind(Project_Kind)
)

func init() {
	SchemeBuilder.Register(&Project{}, &ProjectList{})
}
